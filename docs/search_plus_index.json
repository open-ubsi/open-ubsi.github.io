{"./":{"url":"./","title":"概述","keywords":"","body":"UBSI微服务架构概述 随着应用软件架构模式的不断迭代衍化，云原生的微服务架构已经越来越成为构建现代化应用系统的主流方法。 云原生是一种面向云环境的构建和运行应用的方法，云原生应用的基本特质：组件化、可观察、可独立部署/测试、可动态升级/替换、可配置管理等；云原生是一套技术体系和方法论，主要构成包括：微服务 + DevOps + 持续交付 + 容器。 说起微服务架构，就必须要提到SpringCloud。SpringCloud是目前最被广泛应用的微服务框架，由Netflix公司开发，在SpringBoot框架基础上，通过一系列扩展插件以及外围独立组件，构建出的一套相对完整的微服务开发/运行体系。 虽然SpringCloud已经被广泛采用，但仍存在不少问题： 低性能、高延迟：SpringCloud采用基于HTTP的restful-api作为通信协议，虽然能够获得较高的适用性，但在性能方面代价很大，并非高频的微服务之间RPC通讯的最佳选择 巨大的资源开销：每个微服务在独立运行时，都会带着自己的一套Spring运行框架(包括web容器，如Tomcat等)，框架占用的资源开销已经远远大于一个简单的微服务的开销；当系统中存在成百上千个微服务运行实例时，对于运行资源的需求是一个灾难 系统构成过于复杂，环境搭建/运维的成本高昂：为实现较为完整的微服务治理能力，SpringCloud的运行环境除了微服务本身之外，还需要大量的独立组件，包括注册中心、配置中心、流量控制、链路跟踪、监控工具、分布式日志、分布式事务等，这些都需要单独进行安装、配置和运维 缺乏一个统一的、高度集成的治理工具，除非进行二次开发或采用第三方的整合方案 缺乏服务自动部署以及生命周期管理的工具，必须依赖Docker和K8S 较高的学习成本，难以实现自主可控：开发人员需要深入学习从SpringBoot到SpringCloud的各种插件/组件的注解/API及工作机理，即便是已经非常熟悉的开源工具包(例如mybatis)，也需要再次了解Spring框架对其接口或配置参数进行的封装，这不仅仅对编码工作带来了更高的复杂度，对于测试、优化、系统环境迁移以及TroubleShooting等工作也造成了更加严峻的挑战 UBSI - 轻量级微服务架构平台 针对SpringCloud存在的这些问题，一个全新的轻量级微服务架构平台UBSI - Unified Basic Service Infrastruct应运而生。轻量级意味着更快、更简单、更易学易用，但并不意味着能力的缺失。对比SpringCloud，UBSI同样构建了一套完备的微服务开发/治理体系： SpringCloud UBSI 注册中心 Eureka、Consul、Nacos Redis 配置中心 Spring Cloud Config、Apollo、Nacos UBSI Repo服务仓库组件 流量控制 Hystrix、Sentinel UBSI Container服务容器 路由和负载均衡 Ribbon、Loadbalancer UBSI Consumer客户组件 链路跟踪/分布式日志 Sleuth、SkyWalking UBSI Logger日志服务组件 API网关 Spring Cloud Gateway、Zuul UBSI Gateway网关组件 API文档 Swagger、Knife4j UBSI Repo服务仓库组件 任务调度 Spring Cloud Task UBSI Scheduler任务调度组件 分布式事务 Seata、TxLCN UBSI Transaction分布式事务组件 自动化部署 UBSI Repo服务仓库组件 自动化测试 UBSI Tester服务组件 服务编排或流程 UBSI Eventflow事件流程组件 监控工具 SpringBoot Admin UBSI Admin治理工具 与SpringCloud体系不同，UBSI没有采用拼装或集成大量第三方组件的方式，而是从根本上就对微服务架构进行了一体化的设计，从而形成了一整套高度集成的架构方案。 除此之外，UBSI的优势还体现在： 更高性能、更低延迟：微服务之间的RPC通讯采用基于socket长连接的多路复用机制，并使用与语言无关的二进制数据编码，显著提升了通讯效率；在同样系统环境下的测试结果表明UBSI接口的响应效率在SpringBoot的5倍以上 更少的资源开销：UBSI架构的核心是提供了微服务的运行容器，与Docker容器不同，Docker是系统运行环境容器，可以运行任何应用；UBSI Container更类似于可以部署多个web应用的web容器（如Tomcat），多个不同微服务的运行实例可以部署在同一个UBSI Container中运行，这些实例可以共享容器提供的I/O连接池、工作线程池、过滤器（比如加密认证）等，这种机制可以极大降低微服务的运行资源开销 更简单的系统构成：除了采用Redis作为注册中心，以及Admin治理工具需要的Nginx/MongoDB之外，UBSI的运行环境不再需要其他的独立组件；在UBSI体系中，\"一切都是微服务\"：除了核心的Container/Consumer组件之外，几乎所有的治理能力都是通过UBSI的微服务来实现 一体化的集成治理工具： 不依赖Docker/K8S的微服务自动部署及生命周期管理能力：UBSI的微服务容器并不仅仅是一个微服务的运行容器，还通过\"容器控制器\"（这也是一个特殊的微服务，伴随容器运行）提供了对其他微服务的实例部署、测量监控、启/停/卸载等生命周期管理功能，同时容器还统一管理所有服务实例的注册、流量控制、访问控制及跟踪、请求统计及事务协调等，所以说UBSI不仅仅是一个微服务的开发框架，还是一个运行平台，是微服务应用的基础设施和技术底座 更低的学习成本、更高的开发效率 对于开发人员来说，只需要掌握基础的Java开发技能，并了解几个UBSI的服务注解，就能马上开始微服务的开发 UBSI通过集成开发环境的Maven仓库，可以帮助搭建 \"开发\" -> \"构建\" -> \"发布\" -> \"部署\" 的流水线，能够有效提高微服务的开发迭代效率 UBSI的服务仓库可以集中收录开发组织的工作成果，形成统一的服务目录和接口文档 UBSI还为开发人员提供了一体化的测试及日志工具 UBSI的核心架构： 服务容器(UBSI Container)是UBSI平台的核心组件，容器是可以独立运行的节点，用来装载微服务的运行实例。容器为微服务提供了： 运行时的上下文环境 动态部署、启动、暂停、卸载等生命周期管理 向注册中心注册 处理数据通讯、并发调度、流量控制 向监控工具报告状态及计数 动态参数配置 每个容器可以部署多个微服务，同一个微服务可以部署在多个容器中，多个容器构成了UBSI的服务网格(Service Mesh)。 UBSI平台的整体架构： UBSI可以帮助构建复杂的分布式应用系统或技术/业务中台，满足高性能、易扩展、高可用、易治理等要求，支持快速开发及可持续交付。 "},"develop/readme.html":{"url":"develop/readme.html","title":"微服务开发","keywords":"","body":"微服务开发 我们先通过一个简单的例子来了解一下UBSI微服务的开发，这是一个名为\"ubsi.demo.hello\"的微服务，除了一个简单的业务接口\"hello\"之外，还提供了完整的微服务配置管理接口的实现。 我们将通过下面几个步骤来完成这个微服务的开发： 开发环境准备 开启Java Project 实现业务接口 实现配置管理接口 单元测试 服务部署 观察及访问 完整的示例代码可以访问： https://github.com/open-ubsi/demo.hello "},"develop/environment.html":{"url":"develop/environment.html","title":"开发环境准备","keywords":"","body":"开发环境准备 UBSI微服务需要的开发环境： Java 8+ UBSI目前还不支持其他语言来开发微服务，如果有异构系统需要访问UBSI的微服务，可以通过UBSI Gateway网关 接入。 Java 8应该使用8u291之后的版本 Maven 常用的Java集成开发工具（如IntelliJ）都会带有maven工具，如果没有也可以单独下载并安装； 开发UBSI微服务必须依赖ubsi-core核心包，目前这个包还未发布到maven的中央仓库，而是单独托管在github-packages中 ( https://github.com/orgs/open-ubsi/packages )，所以需要在maven环境的settings.xml中添加如下配置： ...... github {your-github-account} {your-github-Personal_Access_Token} 个人Settings -> Developer settings -> Personal access tokens -> Generate new token --> ...... dev ...... github https://maven.pkg.github.com/open-ubsi/release dev Maven私有仓库服务 UBSI的部署工具及服务仓库管理工具都需要将开发完成的微服务Jar包发布到maven私有仓库中，如果开发环境已经部署了maven仓库服务，需要在maven的settings.xml中进行正确配置： ...... maven-release {your-maven-account} {your-maven-password} maven-snapshot {your-maven-account} {your-maven-password} ...... dev ...... maven-public {your-maven-public-repository-url} true true always dev 如果没有maven私有仓库服务，可以自行下载并安装Nexus3进行搭建，或者在阿里云上申请一个： https://developer.aliyun.com/mvn/search "},"develop/project.html":{"url":"develop/project.html","title":"开启Java Project","keywords":"","body":"开启Java Project 创建一个Java的maven project，然后在pom.xml中添加必要的元素，完整的内容如下： 4.0.0 com.rewin ubsi-service-demo 1.0 1.8 2.3.2 ubsi.demo.hello UBSI微服务示例 com.rewin ubsi-core-ce ${ubsi.version} provided junit junit 4.12 test org.apache.maven.plugins maven-compiler-plugin 3.10.1 ${java.version} ${java.version} utf-8 org.apache.maven.plugins maven-surefire-plugin 3.0.0-M7 true com.rewin ubsi-maven-plugin 1.0.0 ubsi.demo.hello ubsi.demo.hello.Service 对于一个完整的UBSI微服务开发项目，需要在pom.xml中配置下面的内容： 添加ubsi-core核心包的依赖，目前最新的版本是2.3.2 添加junit的依赖，这个用来进行服务接口的单元测试 设置ubsi的maven插件，用来部署或运行微服务 如果需要将微服务的JAR包发布到maven私有仓库，还应该设置mvn deploy时的maven仓库地址（仓库的登录账号配置在maven的settings.xml中） "},"develop/entry.html":{"url":"develop/entry.html","title":"实现业务接口","keywords":"","body":"实现业务接口 准备完基础的Java开发环境，就可以开始UBSI微服务的开发了。 我们通过一个ServiceEntry类来实现微服务的业务接口（类的名字可以任意定义，但必须是public的），每个接口就是该类的一个public成员函数（非static的），并通过@USEntry注解进行声明，示例代码如下： package ubsi.demo.hello; import rewin.ubsi.annotation.USAfter; import rewin.ubsi.annotation.USBefore; import rewin.ubsi.annotation.USEntry; import rewin.ubsi.annotation.USParam; import rewin.ubsi.container.ServiceContext; /** 微服务的接口类（被主类继承） */ public class ServiceEntry { @USBefore public void before(ServiceContext ctx) { ctx.getLogger().info(Service.myName, \"before\"); } @USAfter public void after(ServiceContext ctx) { ctx.getLogger().info(Service.myName, \"after\"); } @USEntry( tips = \"打个招呼\", params = { @USParam(name = \"consumer\", tips = \"调用者的名字\"), // 接口参数说明 }, result = \"响应\", // 返回值的说明 readonly = true, // 只读 timeout = 1 // 超时设置（秒数） ) /* 接口的第一个参数必须是ServiceContext，返回值可以是任意类型 */ public String hello(ServiceContext ctx, String consumer) throws Exception { ctx.getLogger().info(Service.myName, \"hello, \" + consumer); return Service.myName + \": hello, \" + consumer; } } @USEntry可以用来声明接口的说明、输入参数、返回值、是否只读、超时时间等，其中readonly属性参与了容器对接口的访问控制；timeout属性用来帮助容器检测接口的调用是否发生超时； @USEntry声明的接口属性可以通过UBSI Repo服务仓库工具进行提取，进而形成统一的服务接口文档： 在UBSI治理工具的接口查询功能中，顺便还可以对接口做一下测试，如上图所示 这个服务只实现了一个非常简单的hello接口，如果需要多个接口，按照同样的方式进行声明和实现即可；需要注意的是：UBSI要求每个接口的第一个参数必须是一个ServiceContext对象，UBSI容器在收到外部请求并调用对应接口的时候，会通过这个对象传递请求的上下文； 更多信息可以参见 ServiceContext API UBSI服务接口的外部输入参数的数量没有限制，但是每个参数的数据类型必须是UBSI支持的基础数据类型。这是为了保证数据协议的\"语言无关\"特性，UBSI只按照特定的\"基础数据类型\"来传送数据，当发现不支持的类型时，UBSI会自动进行转换，如下表所示： 发送时的数据类型 接收时的数据类型（基础数据类型） boolean boolean byte byte char, short, int int (32位有符号整数) long long BigInteger BigInteger float, double double (64位双精度浮点数) BigNumber BigNumber CharSequence, String String Map HashMap List ArrayList Set HashSet byte[] byte[] T[] (非byte[]的类型数组) Object[] (对象数组) java.util.regex.Pattern java.util.regex.Pattern T (其他Java Class) Map (仅包含public成员变量) 更多信息可以参见 UBSI数据类型及编码方式 在这种\"数据泛化\"的机制下，UBSI的Consumer就不必依赖Provider的任何特定数据类型就可以自由访问所有的服务接口，这对Consumer的开发带来了很大的便利，但是需要注意：在数据接收端（如Provider的接口输入参数或Consumer的请求结果）都只能按照\"基础数据类型\"进行处理； 如果需要将收到的数据映射为特定的数据类型，可以参见 UBSI数据类型转换的相关API "},"develop/service.html":{"url":"develop/service.html","title":"实现配置管理接口","keywords":"","body":"实现配置管理接口 UBSI的每个微服务都需要指定一个用@UService注解声明的类（服务类），所以仅仅一个ServiceEntry（接口类）是不够的，我们用一个继承了ServiceEntry的Service类来作为服务类，并且在这个类中实现微服务的配置管理接口。代码如下： package ubsi.demo.hello; import rewin.ubsi.annotation.*; import rewin.ubsi.common.Util; import rewin.ubsi.container.ServiceContext; /** 微服务的主类 */ @UService( name = Service.SERVICE_NAME, // 默认的服务名字 tips = \"UBSI微服务示例\", // 服务说明 version = \"1.0.0\", // 接口的版本 release = false // 发布状态，false表示社区版 ) public class Service extends ServiceEntry { final static String SERVICE_NAME = \"ubsi.demo.hello\"; // 默认的服务名字 final static String CONFIG_FILE = \"config.json\"; // 配置文件名 static String myName = \"ubsi\"; // 参数配置项，用来demo动态参数配置 /** 服务实例启动时的初始化动作 */ @USInit public static void init(ServiceContext ctx) throws Exception { // 读取配置文件 Config config = ctx.readDataFile(CONFIG_FILE, Config.class); if ( config != null ) { // 读到了配置文件，根据配置文件设置运行参数 myName = config.name; } /* 如果还有其他资源/配置文件放在resources下，可以使用ctx.getResourceAsStream(\"filename\")来读取 */ // 输出服务启动日志 ctx.getLogger().info(\"start\", myName); } /** 服务实例停止时的资源清理动作 */ @USClose public static void close(ServiceContext ctx) throws Exception { // 输出服务停止日志 ctx.getLogger().info(\"stop\", myName); } /** 返回运行信息 */ @USInfo public static String info(ServiceContext ctx) throws Exception { return myName; } /** 返回配置参数 */ @USConfigGet public static Config getConfig(ServiceContext ctx) throws Exception { Config config = new Config(); config.name = myName; // 配置项的运行值 config.name_restart = myName; // 配置项的配置值（该配置项立即生效，不需要从配置文件中读取） return config; } /** 设置配置参数 */ @USConfigSet public static void setConfig(ServiceContext ctx, String json) throws Exception { Config config = Util.json2Type(json, Config.class); myName = config.name; // 动态修改运行参数（如果配置参数要求微服务必须重启后才能生效，则不能立即修改运行值，只能保存配置文件） ctx.saveDataFile(CONFIG_FILE, config); // 保存配置文件 } } @UService注解的name表示微服务的默认名字（在实例部署时还可以指定为其他的名字），微服务的名字、接口版本以及发行状态都会被容器自动注册到注册中心，并参与UBSI Consumer的路由算法。（在A/B测试及灰度发布时，可以配置路由算法指向特定版本的服务实例）； 在正常情况下，微服务应该是\"无状态\"的，这样在运行时，可以部署微服务的多个实例来实现负载分散以及容错；但有些处理特定业务场景的微服务需要以\"活动单例\"方式来运行（只能存在一个\"活动\"的运行实例，比如：依赖内存数据进行业务处理、存在不能并行的定时/轮询任务等），这时只需要将@UService注解的singleton属性设置为true，这个微服务就可以从\"无状态\"的多实例\"并行\"模式转化为\"有状态\"的多实例\"主备\"模式： 当前只有一个实例处于\"运行\"状态（主实例），其他实例都处于\"standby\"状态 当主实例失效或停止后，容器会立刻选择一个standby实例进入\"运行\"状态，切换动作可以在毫秒级完成 之前的实例恢复后，会进入standby状态，成为一个后备实例 更多@UService注解的说明请参见 UBSI注解 除了@UService，微服务还可以通过下面几个接口来为UBSI容器/治理工具提供配置管理能力： @USInit：微服务启动时的初始化 @USClose: 微服务停止时的资源清理 @USInfo: 提供运行时信息 @USConfigGet: 提供运行配置参数 @USConfigSet: 设置运行配置参数 使用这些注解的接口必须是public static的，更多注解请参见 UBSI注解 UBSI不会替微服务保存或\"生效\"配置参数，这些应该由微服务在@USInit/@USConfigSet中进行处理；但UBSI会提供一个统一的参数查看/配置工具，只需要微服务按照@USConfigGet的约定，返回正确的配置信息即可。在本示例中，微服务只有一个配置项，定义在Config类中： package ubsi.demo.hello; /** 微服务的配置 */ public class Config { public String name; // 配置项的当前运行值 public String name_restart; // 配置项的配置值（在配置文件中的值，非当前值） // 如果配置项修改后须重启才能生效，则通过???_restart返回 public String name_comment = \"服务实例的名字\"; // 配置项的说明，通过???_comment返回 } 开发者可以在UBSI治理工具中看到的微服务参数配置页面： UBSI允许为微服务的每个实例单独设置配置参数，也可以将配置信息保存在\"服务仓库\"该微服务的\"默认配置\"中，继而推送到微服务的其他运行实例；\"服务仓库\"的部署工具在部署新实例时也会自动应用这个\"默认配置\"。 "},"develop/unit-test.html":{"url":"develop/unit-test.html","title":"单元测试","keywords":"","body":"单元测试 微服务的代码已经开发完成，那如何进行接口的访问测试呢？我们先从JUnit单元测试开始介绍。 创建一个JUnit 4的测试类（IntelliJ中可以使用数标右键的\"generate > JUnit Test > Junit 4\"），代码如下： package ubsi.demo.hello; import com.google.gson.Gson; import org.junit.Test; import org.junit.Before; import org.junit.After; import rewin.ubsi.cli.Request; import rewin.ubsi.common.Util; import rewin.ubsi.consumer.Context; import rewin.ubsi.container.Bootstrap; import java.util.Map; /** * ServiceEntry Tester. */ public class ServiceEntryTest { @Before public void before() throws Exception { Bootstrap.start(); // 启动测试容器，缺省为 localhost#7112 /* 启动容器时需要rewin.ubsi.module.json文件，否则容器不会自动加载微服务 微服务加载时如果\"startup\"为true，则启动微服务（执行@USInit方法） */ } @After public void after() throws Exception { Bootstrap.stop(); // 关闭测试容器，关闭时会依次停止加载的所有微服务（执行@USClose方法） } /** * 服务接口测试 */ @Test public void testHello() throws Exception { // 创建ubsi请求对象 Context ubsi = Context.request(Service.SERVICE_NAME, \"hello\", \"tester\"); // 发起ubsi请求：direct直连方式通常用于测试/容器治理，正常情况下应该使用call()路由方式 String ack = (String)ubsi.direct(\"localhost\", 7112); // 通过日志输出结果 Context.getLogger(\"junit\", \"test-hello\").info(\"return\", ack); // 通过console输出结果 System.out.println(\"return: \" + ack); } /** * 参数配置测试 * 微服务的参数配置接口通常会由UBSI治理工具调用，这里的测试可以用来验证接口的实现是否正确 */ @Test public void testConfig() throws Exception { // 获取微服务的配置参数：向容器控制器（名为\"\"的微服务）发getConfig请求 Context ubsi = Context.request(\"\", \"getConfig\", Service.SERVICE_NAME); Map config = (Map)ubsi.direct(\"localhost\", 7112); // UBSI在传输数据时会将自定义的Java-Class映射为Map Request.printJson(config); // 输出获取到的配置信息 // 设置微服务的配置参数：向容器控制器（名为\"\"的微服务）发setConfig请求 Map new_cfg = Util.toMap(\"name\", \"new-name\"); String cfg_json = new Gson().toJson(new_cfg); ubsi = Context.request(\"\", \"setConfig\", Service.SERVICE_NAME, cfg_json); ubsi.direct(\"localhost\", 7112); // 设置新的参数（会生成配置文件：rewin.ubsi.modules/ubsi.demo.hello/config.json） testHello(); // 调用hello接口，查看运行参数是否修改 } } 在执行测试前，需要在Project的根目录下手工创建rewin.ubsi.module.json文件，用来指定容器启动时需要自动加载的微服务，内容如下： { \"services\": { \"ubsi.demo.hello\": { \"class_name\": \"ubsi.demo.hello.Service\", \"startup\": true } } } 执行testHello()测试案例，我们会得到如下结果： [INFO] 2022-03-28 14:19:19.922 liuxd-hp#7112 rewin.ubsi.service ubsi.demo.hello [1]ubsi.demo.hello.Service#init()#35 start \"ubsi\" [INFO] 2022-03-28 14:19:24.234 liuxd-hp#7112 rewin.ubsi.container rewin.ubsi.container [1]rewin.ubsi.container.Bootstrap#start()#154 startup \"2.3.0\" return: ubsi: hello, tester [INFO] 2022-03-28 14:19:26.531 liuxd-hp#7112 rewin.ubsi.service ubsi.demo.hello#hello [17]ubsi.demo.hello.ServiceEntry#hello()#20 ubsi \"hello, tester\" [INFO] 2022-03-28 14:19:26.546 liuxd-hp#7112 junit test-hello [1]ubsi.demo.hello.ServiceEntryTest#testHello()#43 return \"ubsi: hello, tester\" [INFO] 2022-03-28 14:19:26.546 liuxd-hp#7112 rewin.ubsi.service ubsi.demo.hello [1]ubsi.demo.hello.Service#close()#42 stop \"ubsi\" [INFO] 2022-03-28 14:19:26.546 liuxd-hp#7112 rewin.ubsi.container rewin.ubsi.container [1]rewin.ubsi.container.Bootstrap#stop()#190 shutdown \"2.3.0\" 从日志我们可以看到代码的完整执行序列： 容器加载微服务：start \"ubsi\" 容器启动成功：startup \"2.3.0\" 接口hello被访问：ubsi \"hello, tester\" 测试用例得到返回结果：return \"ubsi: hello, tester\" 微服务被关闭：stop \"ubsi\" 容器被关闭：shutdown \"2.3.0\" 关于日志格式以及日志配置的更多说明请见 UBSI日志 关于服务结果的输出有一点需要特别注意：在代码顺序中后面的System.out.println()语句的输出结果反而出现在格式化日志输出之前，这是由于UBSI日志采用了异步/批量的输出方式，会有延迟，但不会由于日志信息的I/O处理造成任务线程的等待，从而优化微服务的性能； 再执行testConfig()测试案例，得到如下日志输出： [INFO] 2022-03-28 14:36:19.402 liuxd-hp#7112 rewin.ubsi.service ubsi.demo.hello [1]ubsi.demo.hello.Service#init()#35 start \"ubsi\" [INFO] 2022-03-28 14:36:23.267 liuxd-hp#7112 rewin.ubsi.container rewin.ubsi.container [1]rewin.ubsi.container.Bootstrap#start()#154 startup \"2.3.0\" { \"name_restart\": \"ubsi\", \"name\": \"ubsi\", \"name_comment\": \"服务实例的名字\" } return: new-name: hello, tester [INFO] 2022-03-28 14:36:25.370 liuxd-hp#7112 rewin.ubsi.service ubsi.demo.hello#hello [23]ubsi.demo.hello.ServiceEntry#hello()#20 new-name \"hello, tester\" [INFO] 2022-03-28 14:36:25.372 liuxd-hp#7112 junit test-hello [1]ubsi.demo.hello.ServiceEntryTest#testHello()#43 return \"new-name: hello, tester\" [INFO] 2022-03-28 14:36:25.377 liuxd-hp#7112 rewin.ubsi.service ubsi.demo.hello [1]ubsi.demo.hello.Service#close()#42 stop \"new-name\" [INFO] 2022-03-28 14:36:25.377 liuxd-hp#7112 rewin.ubsi.container rewin.ubsi.container [1]rewin.ubsi.container.Bootstrap#stop()#190 shutdown \"2.3.0\" 我们可以看到微服务的配置项已经成功地从默认的\"ubsi\"改为了\"new-name\"，同时该配置项也已经保存到了配置文件 rewin.ubsi.modules/ubsi.demo.hello/config.json 中。 "},"develop/deploy.html":{"url":"develop/deploy.html","title":"服务部署","keywords":"","body":"服务部署 微服务测试完成后，需要部署到实际的容器中运行（在\"单元测试\"时使用的手工创建rewin.ubsi.module.json文件的方式仅在调试时使用），部署微服务可以通过UBSI的部署工具来完成。 首先需要完成部署前的准备工作： 启动一个独立的UBSI Container微服务容器 java -jar ubsi-core-ce-2.3.2-jar-with-dependencies.jar JAR包下载可以访问 https://github.com/open-ubsi/ubsi-core 容器启动后默认的监听地址为本机（localhost）的7112端口 在项目目录下执行ubsi-maven插件的部署命令（已经在pom.xml中正确配置了ubsi-maven-plugin） mvn ubsi:deploy 利用ubsi-maven插件，还可以直接在项目目录下启动容器并加载微服务： mvn ubsi:run 除了ubsi-maven插件，UBSI正式版本还提供了不依赖项目maven环境的独立命令行部署工具，或者通过UBSI治理工具的服务仓库进行服务部署。详见：https://ubsi-home.github.io/docs/develop/deploy.html "},"develop/consumer.html":{"url":"develop/consumer.html","title":"观察及访问","keywords":"","body":"观察及访问 当微服务成功部署到服务容器后，我们如何观察其运行状态或访问其服务接口呢？ 首先，我们可以使用UBSI治理工具的\"服务发现\"： 在这里，可以查看服务的运行状态、\"启/停/卸载\"服务、修改运行配置、查看接口并执行测试等。 如果没有启用UBSI治理工具，还可以使用UBSI核心包提供的命令行工具： rewin.ubsi.cli.Request - 接口访问工具 java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar rewin.ubsi.cli.Request -h localhost -p 7112 ubsi.demo.hello hello requester rewin.ubsi.cli.Console - 客户端交互工具 > java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar rewin.ubsi.cli.Console UBSI Consumer Console Utility, press ENTER for help localhost#7112> modules [1] \"\": [2.3.2-SNAPSHOT] rewin.ubsi.container.Controller, UBSI微服务容器控制器 [1] ubsi.demo.hello: [1.0.0] ubsi.demo.hello.Service, UBSI微服务示例 localhost#7112> request ubsi.demo.hello hello requester \"ubsi: hello, requester\" localhost#7112> 或者写一个完整的Java Consumer客户端： package ubsi.demo.hello; import rewin.ubsi.consumer.Context; /** 服务消费者测试类 */ public class Test { /** 命令行启动入口 */ public static void main(String[] args) throws Exception { Context.startup(\".\"); // 启动UBSI Consumer，指定\".\"为当前工作目录 callAsync(); callSync(); Context.shutdown(); // 关闭UBSI Consumer } // 同步方式请求 static void callSync() throws Exception { Context ubsi = Context.request(\"ubsi.demo.hello\", \"hello\", \"consumer-sync\"); // 创建UBSI请求对象 String ack = (String)ubsi.call(); // 同步方式发送请求，并等待返回结果 System.out.println(\"return: \" + ack); } // 异步方式请求 static void callAsync() throws Exception { Context ubsi = Context.request(\"ubsi.demo.hello\", \"hello\", \"consumer-async\"); // 创建UBSI请求对象 ubsi.callAsync((code, data) -> { // 在请求结果通知中的处理动作（如果是高耗时操作，为避免长时间占用I/O线程，应启动单独线程处理） System.out.println(\"code: \" + code + \", data: \" + data); }, false); // 异步方式发送请求，通过回调得到结果 } } 在这个示例中，我们采用\"call-路由\"方式来访问微服务。与\"direct-直连\"方式不同，\"路由\"方式不需要指定微服务所在的容器地址，通常是通过\"注册中心\"来动态寻址，但在这个案例中，我们并没有配置\"注册中心\"，所以我们需要使用UBSI Consumer提供的\"静态路由\"机制。 在当前工作目录下手工创建rewin.ubsi.router.json文件，这个是UBSI Consumer的\"静态路由表\"，内容如下： [ { \"Service\": \"*\", \"Nodes\": [ { \"Host\": \"localhost\", \"Port\": 7112 } ] } ] 这个路由配置表示：所有的微服务（\"*\"代表通配符）的访问请求都发送到\"localhost#7112\"容器节点。 执行这个测试： java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar;target\\classes ubsi.demo.hello.Test 会得到下面的返回结果： return: ubsi: hello, consumer-sync code: 0, data: ubsi: hello, consumer-async 注：异步方式的回调接口的code参数表示请求是否正常，0表示成功，此时data参数表示实际的返回结果；code!=0表示失败，此时data为String类型的错误信息。关于错误代码的详细说明请见 UBSI错误代码 "},"filter/readme.html":{"url":"filter/readme.html","title":"过滤器开发","keywords":"","body":"过滤器开发 UBSI的过滤器分为容器端过滤器(container-filter)和访问端过滤器(consumer-filter)。 容器端过滤器类似于微服务，只能部署在容器内运行，与微服务不同的是，过滤器没有名字，也没有服务接口，只有通过@USBefore/@USAfter两个注解声明的\"拦截点\"，可以在微服务接口被访问前/后进行拦截处理，以扩展容器/微服务的处理机制。 过滤器通常会被用来实现更复杂的微服务访问认证、授权、加密、统计等；一个容器内可以部署多个过滤器，服务请求到达容器时，会按照链状顺序进行前/后置处理，如下所示： graph LR A(请求_) --> B(容器_); B --> C(filter1:before_); C --> D(filter2:before_); D --> E(服务接口_); I(处理结果_) --> F(filter2:after_); F --> G(filter1:after_); G --> H(返回_); 访问端的过滤器是一个实现了rewin.ubsi.consumer.Context.Filter接口的Java类，同样是通过before/after两个接口，来对consumer发出服务请求之前及收到请求结果之后进行拦截处理；设置consumer-filter需要通过配置文件rewin.ubsi.consumer.json来进行，同样可以设置多个filter，处理序列与container-filter相同。 我们会通过一个简单的例子来介绍UBSI过滤器的开发： 过滤器Project 容器端过滤器 访问端过滤器 部署及测试 这个例子用来演示在访问ubsi.demo.hello的hello()接口时，对参数和返回结果进行加解密的过程；加解密动作是对称的，所以同时需要container-filter及consumer-filter，具体过程如下： graph LR 请求_ --> consumer-filter-before:加密___; consumer-filter-before:加密___ -- 发送到容器_ --> container-filter-before:解密___; container-filter-before:解密___ --> 服务接口_; 结果_ --> container-filter-after:加密___; container-filter-after:加密___ -- 返回到consumer__ --> consumer-filter-after:解密___; consumer-filter-after:解密___ --> 请求者_; 完整的示例代码可以访问： https://github.com/open-ubsi/demo.filter "},"filter/project.html":{"url":"filter/project.html","title":"过滤器Project","keywords":"","body":"创建过滤器的Project 创建一个Java的maven project，然后在pom.xml中添加必要的元素，完整的内容如下： 4.0.0 com.rewin ubsi-filter-demo 1.0 ubsi.demo.filter UBSI过滤器示例 1.8 2.3.2 com.rewin ubsi-core-ce ${ubsi.version} provided junit junit 4.12 test org.apache.maven.plugins maven-compiler-plugin 3.10.1 ${java.version} ${java.version} utf-8 org.apache.maven.plugins maven-surefire-plugin 3.0.0-M7 true com.rewin ubsi-maven-plugin 1.0.0 ubsi.demo.filter.Container "},"filter/container.html":{"url":"filter/container.html","title":"容器端过滤器","keywords":"","body":"容器端过滤器 容器端过滤器的代码如下： package ubsi.demo.filter; import org.bouncycastle.util.encoders.Hex; import rewin.ubsi.annotation.USAfter; import rewin.ubsi.annotation.USBefore; import rewin.ubsi.annotation.USFilter; import rewin.ubsi.consumer.ErrorCode; import rewin.ubsi.container.ServiceContext; import java.nio.charset.StandardCharsets; /** UBSI容器过滤器 */ @USFilter( tips = \"UBSI过滤器示例\", // 说明 version = \"1.0.0\", // 版本 release = false // 发布状态，false表示社区版 ) public class Container { final static String HEADER_KEY = \"ubsi.demo.filter\"; boolean deal = false; // 是否需要加解密处理 /** 服务接口调用前的拦截动作 */ @USBefore public void before(ServiceContext ctx) throws Exception { if ( !\"ubsi.demo.hello\".equals(ctx.getServiceName()) || !\"hello\".equals(ctx.getEntryName()) ) return; // 仅对ubsi.demo.hello服务的hello()接口做处理 // 从请求的Header中获得加密标志 Boolean encrypt = (Boolean) ctx.getHeader(HEADER_KEY); if ( encrypt != null && encrypt ) { // 请求参数已经加密了 String param = (String)ctx.getParam(0); // 获取参数 if ( param != null && !param.isEmpty() ) { param = new String(Hex.decode(param), StandardCharsets.UTF_8); // 将16进制字符串转换为实际参数(伪解密) ctx.setParam(param); // 将参数设置为解密后的字符串 deal = true; } } } /** 服务接口调用后的拦截动作 */ @USAfter public void after(ServiceContext ctx) throws Exception { if ( deal && ctx.hasResult() && ctx.getResultCode() == ErrorCode.OK ) { // 接口成功返回且需要处理 String res = (String)ctx.getResultData(); // 获得返回结果 res = Hex.toHexString(res.getBytes(StandardCharsets.UTF_8)); // 将结果转换为16进制字符串(伪加密) ctx.setResultData(res); // 将结果设置为加密后的字符串 } } } 说明： 容器端过滤器的主类需要用@USFilter注解进行声明 过滤器只对ubsi.demo.hello服务的hello()接口进行处理 过滤器进行处理前需要判断请求Header中的ubsi.demo.filter属性，如果未设置，可能是Consumer未设置对应的consumer-filter，这时不做处理，请求依然可以正常进行 "},"filter/consumer.html":{"url":"filter/consumer.html","title":"访问端过滤器","keywords":"","body":"访问端过滤器 访问端过滤器的代码如下： package ubsi.demo.filter; import org.bouncycastle.util.encoders.Hex; import rewin.ubsi.consumer.Context; import rewin.ubsi.consumer.ErrorCode; import java.nio.charset.StandardCharsets; /** UBSI Consumer过滤器 */ public class Consumer implements Context.Filter { boolean deal = false; // 是否需要加解密处理 @Override /** 请求前置接口，返回：0-正常，-1-拒绝，1-降级（使用Mock数据） */ public int before(Context ctx) { if ( \"ubsi.demo.hello\".equals(ctx.getService()) && \"hello\".equals(ctx.getEntry()) ) { // 仅对ubsi.demo.hello服务的hello()接口做处理 String param = (String)ctx.getParam(0); if ( param != null && !param.isEmpty() ) { // 需要对参数进行加密处理 String enc_param = Hex.toHexString(param.getBytes(StandardCharsets.UTF_8)); // 将参数转换为16进制字符串(伪加密) ctx.setParam(enc_param); // 将参数设置为加密后的字符串 ctx.setHeader(Container.HEADER_KEY, true); // 设置请求Header的加密标志 deal = true; System.out.println(\"before: 参数 \\\"\" + param + \"\\\" 被加密为 \\\"\" + enc_param + \"\\\"\"); } } return 0; } @Override /** 请求后置接口 */ public void after(Context ctx) { if ( deal && ctx.getResultCode() == ErrorCode.OK ) { // 接口成功返回，且需要进行处理 String res = (String)ctx.getResultData(); String dec_res = new String(Hex.decode(res), StandardCharsets.UTF_8); // 将16进制字符串转换为实际结果(伪解密) ctx.setResult(ErrorCode.OK, dec_res); // 将结果设置为解密后的字符串 System.out.println(\"after: 结果 \\\"\" + res + \"\\\" 被解密为 \\\"\" + dec_res + \"\\\"\"); } } } 说明： 访问端过滤器是rewin.ubsi.consumer.Context.Filter接口的实现类 过滤器只对ubsi.demo.hello服务的hello()接口进行处理 过滤器处理后，会设置请求Header中的ubsi.demo.filter属性为true，表示参数已被加密 "},"filter/test.html":{"url":"filter/test.html","title":"部署及测试","keywords":"","body":"过滤器部署及测试 首先要部署容器端过滤器，部署步骤如下： 启动一个容器，并加载ubsi.demo.hello服务 -> 在demo.hello的项目目录下执行： mvn ubsi:run 将ubsi.demo.filter的容器过滤器部署到刚启动的容器 localhost#7112 -> 在demo.filter的项目目录下执行： mvn ubsi:deploy 容器端过滤器部署成功后，我们可以用Request命令行工具来访问一下服务接口。 先要设置consumer-filter，在一个单独的目录下创建rewin.ubsi.consumer.json文件，内容如下： { \"filters\": [ \"ubsi.demo.filter.Consumer\" ] } 然后执行Request命令： java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar;ubsi-filter-demo-1.0.jar rewin.ubsi.cli.Request ubsi.demo.hello hello 测试员 会得到如下输出结果： before: 参数 \"测试员\" 被加密为 \"e6b58be8af95e59198\" after: 结果 \"756273693a2068656c6c6f2c20e6b58be8af95e59198\" 被解密为 \"ubsi: hello, 测试员\" \"ubsi: hello, 测试员\" "},"core/readme.html":{"url":"core/readme.html","title":"核心组件","keywords":"","body":"UBSI核心组件 UBSI运行时的核心架构如下： 服务注册 UBSI采用redis作为注册中心，UBSI的Container服务容器负责定时将容器位置、各服务实例的状态/访问计数等更新到redis中，同时利用publish/subscribe机制广播容器的\"活动心跳\"以及各服务实例的状态变化。 注册中心的高可用性可以通过部署redis集群来保障。 服务发现 / 动态路由 UBSI的Consumer组件通过redis的服务注册数据以及容器的广播消息来构建本地的“动态”服务路由，当有服务请求时，通过路由算法将请求发送到合适的服务实例上。 Consumer组件能够实时观察各服务容器的健康状态以及负载情况，路由算法可以做到隔离故障并且按照“响应能力越强则选中概率越高“的机制选择合适的服务容器。 服务访问 UBSI服务请求的处理流程如下： sequenceDiagram 应用->>Consumer组件: 发起服务请求 Consumer组件-->>Container服务容器: 路由选择并发送请求 Container服务容器->>服务实例: 调用实际的服务接口 服务实例->>Container服务容器: 接口返回结果 Container服务容器-->>Consumer组件: 发送处理结果 Consumer组件->>应用: 返回结果 "},"core/container.html":{"url":"core/container.html","title":"Container服务容器","keywords":"","body":"UBSI服务容器 服务容器(UBSI Container)是UBSI平台的核心组件，容器是可以独立运行的节点，用来装载微服务的运行实例。容器为微服务提供了： 运行时的上下文环境 动态部署、启动、暂停、卸载等生命周期管理 向注册中心注册 处理数据通讯、并发调度、流量控制 访问控制、动态参数配置 服务依赖、访问链路跟踪 \"单例\"服务的运行状态控制 分布式事务协调 访问计数及访问日志 每个容器可以部署多个微服务的实例，同一个微服务的多个实例也可以分别部署在不同容器中（并行或主备）；同时，每个容器还会包含一个公共的Consumer组件，以管理和跟踪微服务之间的相互调用；这样的多个容器构成了UBSI的服务网格(Service Mesh)，微服务之间的相互调用实际上都是发生在\"容器容器\"之间，都在容器的\"观察和管控\"之下，由此才构建出了高度一体化的UBSI微服务治理能力。 容器是UBSI最基础的治理单元，每个运行时的容器都会自带一个\"容器控制器\"，这也是一个标准的UBSI微服务，通过一系列接口为治理工具提供了容器以及其中微服务实例的配置/监控/安装卸载等功能。 与其他微服务不同的是，容器控制器的名字为\"\"，可以关闭或重启，但不可停止或卸载 容器的运行参数配置 容器的运行参数保存在配置文件rewin.ubsi.container.json中，一个样例如下： { \"host\": \"container-hostname\", \"port\": 7112, \"backlog\": 128, \"io_threads\": 4, \"work_threads\": 20, \"overload\": 200, \"timeout_fuse\": 0, \"forward\": 0, \"forward_door\": [] } host | port 容器所在服务器的访问地址（建议使用DNS域名，不建议使用IP）和端口 backlog 建立socket连接的等待队列长度 io_threads 用来处理socket I/O的线程数，0表示默认设置（CPU内核数 * 2） work_threads 处理服务请求的并发线程数量 overload 等待处理的请求队列长度，如果等待队列已满，新的请求会被拒绝 timeout_fuse 当某个服务接口超时的数量达到多少个后熔断（拒绝该接口的后续请求），0表示不熔断 forward 转发请求时的等待超时时间（秒数），0表示不转发 forward_door 需注册的\"转发\"微服务 容器通过work_threads/overload/timeout_fuse实现并发及流量控制；开放\"forward\"的容器可以被视为一个\"边界\"容器，配合forward_door以及容器内Consumer组件的静态路由设置，可以构造出\"多治理域\"的微服务运行环境，这对于拥有大规模微服务部署实例的场景（如技术中台）是有意义的，可以实现微服务的\"分区\"治理。 对于容器的运行实例，不需要手工修改配置参数，可以通过UBSI治理工具进行动态配置 注册中心配置 如果需要给容器添加注册中心的配置，还需要在rewin.ubsi.consumer.json配置文件中设置redis的访问参数，详见 Consumer组件。 "},"core/consumer.html":{"url":"core/consumer.html","title":"Consumer组件","keywords":"","body":"Consumer组件 要访问UBSI微服务，必须使用Consumer组件。UBSI目前只提供了Java的实现（后续会陆续提供其他语言的接口包），如果异构系统需要访问，可以使用 UBSI Gateway网关。 UBSI Consumer提供的功能： 统一的微服务访问接口（不依赖任何微服务Provider的实现类） 支持同步/异步机制 基于注册中心的服务发现和动态路由 静态路由配置 服务接口的仿真 一个Consumer组件的简单示例： import rewin.ubsi.consumer.Context; public class Test { public static void main(String[] args) throws Exception { // 启动UBSI Consumer，指定\".\"为当前工作目录 Context.startup(\".\"); // 创建UBSI请求对象 Context ubsi = Context.request(\"ubsi.demo.hello\", \"hello\", \"consumer\"); // 同步方式发送请求，并等待返回结果 String res = (String)ubsi.call(); // 关闭UBSI Consumer Context.shutdown(); } } 关于Context类的更多说明请见 Consumer Context API 需要注意的是：如果是在一个微服务中访问其他的微服务，请不要直接使用Consumer组件的Context.request()来创建请求对象，应该使用容器提供的ServiceContext的request()方法，ServiceContext封装了容器中的Consumer组件，可以保证服务依赖、访问链路以及事务传播的有效性。另外，也不需要进行Context的startup/shutdown操作，容器启动时已经完成了Consumer组件的准备工作。 关于ServiceContext类的更多说明请见 Service Context API Consumer的运行参数配置 Consumer的运行参数保存在配置文件rewin.ubsi.consumer.json中，一个简单的样例如下： { \"io_threads\": 4, \"timeout_connect\": 5, \"timeout_request\": 10, \"timeout_reconnect\": 600, \"redis_host\": \"{redis-server-address}\", \"redis_port\": 6379, \"redis_conn_idle\": 2, \"redis_conn_max\": 16, } io_thread Consumer组件用来处理socket I/O的线程数，0表示默认设置（CPU内核数*2） timeout_connect 向服务容器发起socket连接时的缺省超时时间，秒数 timeout_request 服务请求的缺省超时时间，秒数 timeout_reconnect 发现容器/redis服务节点失效后，再次重试的时间间隔，秒数 redis_host | redis_port redis服务的地址和端口 redis_conn_idle redis连接池的最大空闲数量 redis_conn_max redis连接池的最大数量 上面的配置是针对redis单节点模式，如果部署了多节点的\"哨兵\"模式，需要设置redis_master_name和redis_sentinel_addr； 对于容器和WebApp，Consumer的运行参数可以通过UBSI治理工具进行动态配置 Consumer的静态路由配置 Consumer的静态路由保存在配置文件rewin.ubsi.router.json中，一个样例如下： [ { \"Service\": \"ubsi.demo.*\", \"Nodes\": [ { \"Host\": \"localhost\", \"Port\": 7112, \"Weight\": 2 }, { \"Host\": \"localhost\", \"Port\": 7113, \"Weight\": 1 } ] } ] 这个路由配置表示：所有以\"ubsi.demo.\"开头的微服务的访问请求都按照2:1的比例分别发送到\"localhost#7112\"和\"localhost#7113\"两个容器。如果将某个容器的Weight设置为0（默认值为1），表示这是一个\"备用\"容器，只有当另一个容器失效后才会启用。 需要注意同时存在动态路由和静态路由时，静态路由的优先级在动态路由之上 对于容器和WebApp，Consumer的静态路由可以通过UBSI治理工具进行动态配置 "},"core/logger.html":{"url":"core/logger.html","title":"分布式日志","keywords":"","body":"分布式日志 UBSI为微服务的开发提供了一套完整的日志处理框架： Consumer组件提供了Logger API 可以通过配置来指定不同类型日志的输出方式，包括：console、log-file、远程的日志服务 日志数据的\"输出\"是独立的后台任务通过异步方式进行批量处理，不影响正常任务的处理效率 可以通过独立部署的rewin.ubsi.logger日志微服务，来统一收集其他各处（包括微服务/应用等）产生的日志，并利用UBSI的日志工具进行分析 可以通过配置来指定对微服务的请求进行\"跟踪\"，服务容器/Consumer组件会自动产生相应的请求/处理日志，并利用UBSI的日志工具进行访问链路分析 支持slf4j日志接口（默认的输出级别为WARN） 以服务容器的一条\"启动\"日志为例（日志的默认配置是输出到console），看一下日志数据的格式： [INFO] 2022-03-28 14:36:23.267 liuxd-hp#7112 rewin.ubsi.container rewin.ubsi.container [1]rewin.ubsi.container.Bootstrap#start()#154 startup \"2.3.0\" 其中： [INFO] 日志类型，其他还可以有：DEBUG(测试)、WARN(警告)、ERROR(错误)、ACTION(操作)、ACCESS(访问) 等，应用还可以使用自定义的类型，表示为：[APP#??] 2022-03-28 14:36:23.267 产生日志的时间戳，如果系统时区和JVM时区有差异，可以在启动java应用时指定时区参数，比如： java -Duser.timezone=GMT+8 -jar xxxx.jar liuxd-hp#7112 输出日志的应用所在的位置 rewin.ubsi.container 应用的分类标签 rewin.ubsi.container 应用的ID [1]rewin.ubsi.container.Bootstrap#start()#154 日志输出语句所在的代码位置（[线程编号]类#方法()#行号） startup 日志的输出消息 \"2.3.0\" 日志的附加数据（json格式字符串） 对于Consumer应用，可以通过 Context.getLogger() 获得Logger对象；对于微服务，应该使用 ServiceContext对象的 getLogger() 来获得Logger对象。 Logger对象产生的日志可以通过UBSI治理工具来设置\"输出\"方式： 输出到\"日志服务器\"意味着将不同节点上的各个应用的日志数据都发送到rewin.ubsi.logger日志服务，并统一保存到mongo数据库中。这种机制实现了分布式环境下的日志集中收集，并可以通过UBSI治理工具进行统计分析： "},"transaction.html":{"url":"transaction.html","title":"分布式事务","keywords":"","body":"分布式事务 从版本2.3.0开始，UBSI的Container服务容器就能够支持微服务接口的\"事务\"注解，配合UBSI的事务管理器，UBSI为微服务的开发提供了高性能和简单易用的分布式事务方案。 分布式事务只在UBSI的正式版本提供，详见 https://ubsi-home.github.io/docs/transaction/readme.html UBSI采用了TCC(Try-Confirm-Cancel)分布式事务模型，事务的处理流程与传统事务的两阶段提交协议(XA)类似，只不过需要一个全局事务管理器进行协调，但不限制每个分支节点如何实现自己的本地事务（分支事务）。 例如一个简单的服务访问场景： graph LR; 事务发起者_ --> 微服务A_; 事务发起者_ --> 微服务C_; 微服务A_ --> 微服务B_; 在这个场景中，服务A/B/C都分别有自己的业务数据处理，如果开启了UBSI事务，其处理流程如下： sequenceDiagram participant tc as 事务发起者 participant sa as 微服务A participant sb as 微服务B participant sc as 微服务C participant tm as 事务管理器 tc->>tm: 开启全局事务 - Try tc->>sa: 访问请求 sa->>sb: 访问请求 sb-->>tm: B成功，注册分支事务B sb->>sa: 成功返回 sa-->>tm: A成功，注册分支事务A sa->>tc: 成功返回 tc->>sc: 访问请求 sc-->>tm: C成功，注册分支事务C sc->>tc: 成功返回 tc->>tm: 提交全局事务 - Confirm tm-->>sb: 提交分支事务B tm-->>sa: 提交分支事务A tm-->>sc: 提交分支事务C tm->>tc: 提交成功 在UBSI的分布式事务方案中： 服务容器在声明了\"事务\"的接口处理成功完成后，自动在\"事务管理器\"注册一个\"分支事务\"；所有的事务动作结束后，\"事务管理器\"会自动会每个\"分支事务\"进行提交 \"事务管理器\"是一个UBSI的标准微服务，支持多实例并行部署以保障可靠性 参与事务的微服务接口必须使用@USTxTry注解进行进行声明，并需要提供用@USTxConfirm/@USTxCancel声明的用于处理提交动作（包括commit/rollback）的接口，这两个接口不需要使用@USEntry声明为对外服务接口，UBSI容器会自动处理分支事务commit/rollback动作的调度 独立的Consumer客户端如果要开启事务需要使用rewin.ubsi.consumer.Transaction，示例代码如下： // 开启一个新的全局事务 try (Transaction tx = Transaction.start(\"全局事务分组\", \"事务名称\", 10)) { // 构造一个事务场景下的服务请求 Context context = tx.request(\"demo.tx\", \"buy\", \"apple\", 1); context.call(); tx.commit(); // 事务提交 } // 如果失败，tx会自动进行事务回滚 在微服务中开启全局事务，只需要正确声明@USTxTry注解即可，不需要直接使用Transaction对象。 "},"gateway/readme.html":{"url":"gateway/readme.html","title":"服务网关","keywords":"","body":"服务网关 在复杂的企业IT系统环境中，各种不同的业务系统（应用）可能是用不同的技术方案（异构）独立建设的，但是由\"微服务\"所代表的核心业务逻辑在应用之间应该是一致并且可以被\"共享\"的。在这种环境下，\"微服务\"已经不再仅仅是单一应用内的架构模式，而是可以成为企业内保障关键业务能力的\"中台\"系统。 UBSI API Gateway（服务网关）为企业内的各种异构应用访问\"微服务\"提供了\"统一\"的接口及管控机制，逻辑架构如下： UBSI-Gateway是一个独立的Web应用（WebApp，但不包含前端界面），通过rest-api为其他应用或异构系统提供UBSI微服务的访问能力。 UBSI-Gateway为第三方应用提供了丰富的访问策略，包括： 应用认证、接口/主机授权 路由规则 限流策略 流量镜像/转发（分流） 接口仿真及缓存 访问统计及日志 UBSI-Gateway通过 微服务rewin.ubsi.gateway 来存取访问策略及数据，管理人员可以通过UBSI治理工具来配置这些策略。 UBSI-Gateway服务网关目前只在UBSI正式版本中提供，详见 https://ubsi-home.github.io/docs/gateway/readme.html "},"admin.html":{"url":"admin.html","title":"治理工具","keywords":"","body":"治理工具 UBSI-Admin是一个高度集成化的UBSI微服务治理工具，主要的功能包括： 运行监控 服务发现 微服务/过滤器的自动发现及运行监控 容器发现 运行容器的自动发现及配置管理 WebApp发现 WebApp的自动发现及配置管理 手动发现 手工标记并管理服务容器/WebApp 服务仓库 微服务查询 在仓库中注册的微服务的查询及管理 JAR包管理 从Maven仓库中导入的微服务JAR包的管理 测试管理 功能测试 功能测试用例/测试任务的管理 性能测试 性能测试用例/测试任务的管理 日志分析 服务访问日志 全局的服务访问日志分析、访问链路跟踪 服务运行日志 全局的服务运行日志分析 日志过滤器设置 设置过滤特定日志数据的过滤器 网关管理 网关运行监控 网关的运行实例监控以及访问统计 应用管理 应用信息及访问密钥的管理 远程主机管理 应用所在主机的访问权限控制 接口访问管理 应用对服务接口的访问权限控制 路由规则管理 应用对服务的访问路由设置 限流规则管理 应用对服务的访问流量的限制规则 请求转发规则管理 请求流量的转发或镜像 服务仿真数据管理 服务接口对应用的数据仿真 接口缓存规则管理 应用访问接口的结果缓存规则 服务访问日志管理 应用对接口的访问日志记录规则 任务调度 代码片段 任务需要包含的公共脚本代码的管理 任务管理 定时任务的设置及运行监控 Web服务脚本 脚本管理 作为rest-api的脚本代码管理 脚本权限 脚本代码的执行权限管理 目录管理 文件服务rest-api的目录映射管理 服务流程编排 事件管理 用于激活流程的事件定义 流程定义 可视化的服务流程编排工具 流程执行实例 可视化的流程执行过程跟踪 事务监控 全局/分支事务的执行监控 UBSI-Admin治理工具目前只在UBSI正式版本中提供，详见 https://ubsi-home.github.io/docs/admin/readme.html "},"appendix/readme.html":{"url":"appendix/readme.html","title":"附录","keywords":"","body":"附录 UBSI注解 服务注解 接口注解 数据注解 Service Context API 数据类型及编码 数据类型转换API Consumer Context API 错误代码 命令行工具 JS脚本API Redis消息事件API 国密算法API "},"appendix/annotation.html":{"url":"appendix/annotation.html","title":"UBSI注解","keywords":"","body":"UBSI注解 UBSI通过一系列预定义的注解来声明微服务及其接口，这些注解包括： 服务注解 @UService - 声明微服务 @USFilter - 声明过滤器 @USDepend - 声明服务的依赖关系 接口注解 @USEntry - 声明服务接口 @USParam - 声明接口参数 @USBefore - 声明前置拦截方法 @USAfter - 声明后置拦截方法 @USInit - 声明初始化方法 @USClose - 声明结束方法 @USInfo - 声明获取运行信息的方法 @USConfigGet - 声明获取配置参数的方法 @USConfigSet - 声明设置配置参数的方法 数据注解 @USNotes - 声明一个数据模型 @USNote - 声明数据模型中的一个属性 "},"appendix/annotation/service.html":{"url":"appendix/annotation/service.html","title":"服务注解","keywords":"","body":"服务注解 UBSI的服务注解包括： @UService - 声明微服务 @USFilter - 声明过滤器 @USDepend - 声明服务的依赖关系 @UService 用来标注Java Class，将其声明为一个微服务，例如： package my.service.samples; import rewin.ubsi.annotation.*; import rewin.ubsi.container.ServiceContext; @UService( name = \"my.samples.demo\", // 微服务的名字，缺省为\"\" tips = \"测试服务\", // 微服务的说明，缺省为\"\" version = \"1.0.0\", // 接口的版本号，缺省为\"0.0.1\" release = false, // 版本发行状态：true 或 false，缺省为false depend = { // 依赖的其他微服务，缺省为{} @USDepend( // 第一个依赖，可以有多个 name = \"my.samples.xxx\", // 依赖的微服务的名字 version = \"\", // 该微服务的最小版本 release = false // 该微服务是否必须是\"release\"状态 ) }, container = \"1.0.1\", // 依赖的容器的版本号（1.0.1版本开始支持），缺省为\"\" syslib = { \"jaxen-1.2.0.jar\" }, // 需要加载到SystemClassLoader中的Jar包，缺省为{}（容器版本>=1.0.1） singleton = false // 本服务为单例服务，可以部署多实例，在部署了redis注册中心的环境中，容器会保证只有1个实例在运行，其他实例会处于\"单例等待\"状态(备用)，缺省为false（容器版本>=2.0.0） ) public class DemoService { // 这是一个UBSI微服务，请注意： // class的声明必须是public，并且有无参数的构造函数 } @USFilter 用来声明一个UBSI微服务的过滤器，除了没有\"name/singleton\"属性，其他都跟@UService相同，示例如下： /** 这是一个UBSI Filter */ @USFilter( tips = \"这是一个filter\" ) public class DemoFilter { @USBefore public void before(ServiceContext ctx) throws Exception { ctx.getLogger().info(\"服务容器开始处理一个服务请求\"); } @USAfter public void after(ServiceContext ctx) throws Exception { ctx.getLogger().info(\"服务容器已经完成一个服务请求的处理\"); } } @USFilter与@UService都是由服务容器(Container)加载运行的Class，但与@UService不同，@USFilter不提供对外的访问接口，而是可以通过@USBefore/@USAfter定义的入口拦截本容器所有的服务请求，从而可以记录或改变处理行为。 @USDepend 用在@UService/@USFilter注解的depend属性中，声明依赖的其他微服务，示例请见@UService注解。 "},"appendix/annotation/entry.html":{"url":"appendix/annotation/entry.html","title":"接口注解","keywords":"","body":"接口注解 UBSI的接口注解包括： @USEntry - 声明服务接口 @USParam - 声明接口参数 @USBefore - 声明前置拦截方法 @USAfter - 声明后置拦截方法 @USInit - 声明初始化方法 @USClose - 声明结束方法 @USInfo - 声明获取运行信息的方法 @USConfigGet - 声明获取配置参数的方法 @USConfigSet - 声明设置配置参数的方法 @USEntry 用来声明微服务的接口，例如： @UService( name = \"my.samples.demo\" ) public class DemoService { @USEntry( tips = \"回显\", // 接口的说明 params = { @USParam( // 第一个参数，可以有多个 name = \"args\", // 参数的名字 tips = \"参数\" // 参数的说明 ) }, result = \"返回传入的参数\", // 结果的说明 readonly = true, // 是否是\"只读\"接口，缺省为true timeout = 1 // 超时时间（秒数），缺省为1 ) public Object echo(ServiceContext ctx, Object args) { return args; } } 注意： 被标注方法的第一个参数必须是ServiceContext（通过该参数可以获得请求的上下文），后续可以附加任意数量的参数 附加参数的说明应该放在@USEntry注解的params属性中，必须按照顺序一一对应，以生成正确的接口文档 附加参数以及返回结果的数据类型必须是UBSI支持的基础数据类型，详见\"UBSI基础数据类型\" readonly属性用来声明该接口是否会改变微服务的运行状态或数据，UBSI服务容器可以根据这个属性来设置访问权限 timeout属性用来声明该接口\"正常\"的处理时间，UBSI服务容器可以根据这个属性来发现处理超时的请求 被标注的方法必须是public的（非static），并且不能重名 在运行时，每次服务请求都会使用一个新的@UService实例，所以接口方法不需要考虑并发重入造成的冲突（除非是对静态数据的访问） @USParam 用在@USEntry注解的params属性中，声明接口的参数，示例请见@USEntry注解。 @USBefore | @USAfter 可以用在@UService或@USFilter声明的Class中，定义在一个服务请求\"开始\"或\"结束\"时的拦截动作，例如： @UService( name = \"my.samples.demo\" ) public class DemoService { @USBefore( timeout = 1 // 超时时间（秒数），缺省为1 ) public void before(ServiceContext ctx) throws Exception { ctx.getLogger().info(\"开始处理一个请求\"); } @USAfter( timeout = 1 // 超时时间（秒数），缺省为1 ) public void after(ServiceContext ctx) throws Exception { ctx.getLogger().info(\"完成了一个请求的处理\"); } } 注意： 被标注的方法只能有一个ServiceContext参数，可以通过该参数获得请求的内容或者容器的上下文环境，更多详情可以参见ServiceContext的API @UService的before/after只能拦截对本服务的请求，@USFilter可以拦截本容器内所有微服务的请求 @USInit | @USClose 微服务/过滤器的初始化动作，示例： @UService( name = \"my.samples.demo\" ) public class DemoService { @USInit public static void init(ServiceContext ctx) throws Exception { ctx.getLogger().info(\"微服务启动，进行初始化\"); } @USClose public static void close(ServiceContext ctx) throws Exception { ctx.getLogger().info(\"微服务关闭，进行清理\"); } } 注意： 被标注的必须是public static方法，且只有一个ServiceContext参数 当开始加载微服务/过滤器，或者是监控工具\"停止 | 启动\"服务时，容器会调用这两个方法 如果没有必要，可以不使用这两个注解 @USInfo 用来向UBSI治理工具报告运行信息的接口，示例： /** 返回运行信息 */ @USInfo public static Object info(ServiceContext ctx) throws Exception { return \"当前的运行数据，可以是自定义的数据结构\"; } 注意： 被标注的必须是public static方法 @USInfo接口不能被外部直接访问，而是通过UBSI容器封装的监控接口来调用，有可能会在@USInit之前或@USClose之后被访问 如果没有必要，可以不使用这个注解 @USConfigGet | @USConfigSet UBSI微服务可以通过这两个注解实现运行时的动态参数配置，示例： /** 返回配置参数 */ @USConfigGet public static Object getConfig(ServiceContext ctx) throws Exception { return \"这是配置参数\"; } /** 设置配置参数 */ @USConfigSet public static void setConfig(ServiceContext ctx, String json) throws Exception { //todo 处理传入的配置参数 } 注意： 被标注的必须是public static方法 @USConfigGet可以返回任意数据结构的配置参数，UBSI配置管理工具会将其转换为json格式的字符串展示给管理员，并将修改后的配置（json格式字符串）传递给@USConfigSet进行处理。UBSI治理工具可以通过这两个接口对微服务进行动态配置，为了适应不同微服务的不同配置方式，UBSI治理工具对@USConfigGet返回的数据格式有个默认约定，示例如下： { \"param1\": \"配置参数的当前值\", \"param1_restart\": \"配置参数的配置值（可能需要微服务重启后才能生效）\", \"param1_comment\": \"配置参数的说明\", \"param2\": { ... }, \"param2_restart\": { ... }, \"param2_comment\": { \"参数属性的名字\": \"参数属性的说明\", ... } } 其中\"_restert\"和\"_comment\"是默认的后缀，分别表示该项参数的\"配置值\"和\"说明\"；如果某项参数是一个\"键值对\"，则其对应的\"_comment\"为该参数各个键值属性的说明。遵循这种约定，UBSI治理工具可以构造出下面的参数配置界面：（以服务容器的参数配置为例） 如果需要将配置参数保存为本地的配置文件，@USConfigSet可以通过ServiceContext提供的API获得本地配置文件的存放路径等环境信息；通常情况下，@USConfigSet设置的是每个服务实例的运行参数，不同的服务实例可以有不同的运行参数 这两个接口不能被外部直接访问，而是通过UBSI容器封装的监控接口来调用，有可能会在@USInit之前或@USClose之后被访问 如果没有必要，可以不使用这两个注解 "},"appendix/annotation/data.html":{"url":"appendix/annotation/data.html","title":"数据注解","keywords":"","body":"数据注解 UBSI的数据注解包括： @USNotes - 声明一个数据模型 @USNote - 声明数据模型中的一个属性 @USNotes | @USNote 如果微服务的输入参数或返回结果包含有特定的数据结构时，可以通过这两个注解对自定义的数据结构进行描述，以方便开发人员对数据进行处理。示例： package my.service.samples; import rewin.ubsi.annotation.*; import rewin.ubsi.container.ServiceContext; import java.util.*; @UService( name = \"my.samples.demo\", // 微服务的名字，缺省为\"\" tips = \"测试服务\", // 微服务的说明，缺省为\"\" ) public class DemoService { @USNotes(\"运行信息\") // 标注一个数据模型 public static class RuntimeInfo { @USNote(\"实例的名字\") // 标注模型中的属性 public String instanceName; @USNote(\"启动时间\") public long timestamp; } @USEntry( tips = \"获得数据模型的说明\", result = \"数据模型的说明，格式：{ \\\"模型1\\\": { \\\"字段1\\\": \\\"描述\\\", ... }, ... }\" ) public Map> getModels(ServiceContext ctx) { return Util.getUSNotes(RuntimeInfo.class); // 提取@USNotes注解的工具 } @USEntry( tips = \"获得运行信息\", result = \"Map，对应RuntimeInfo模型\" ) public RuntimeInfo getRuntimeInfo(ServiceContext ctx) throws Exception { RuntimeInfo info = new RuntimeInfo(); info.instanceName = \"实例名字\"; info.timestamp = System.currentTimeMillis(); return info; // 访问端接收到的是一个经过泛化的Map对象 } } 注意： 被标注的必须是public class及其成员变量 可以通过一个特定的服务接口来返回标注的模型 "},"appendix/service-context.html":{"url":"appendix/service-context.html","title":"Service Context API","keywords":"","body":"rewin.ubsi.container.ServiceContext 构造函数 public ServiceContext(String name); 参数： name - 微服务名字 返回： 无 获得服务的配置文件的存放目录 public String getLocalPath(); 参数： 无 返回： 微服务配置文件所在的本地路径 获得服务的资源文件 public InputStream getResourceAsStream(String filename); 参数： 资源文件名 返回： 资源文件的输入流 获得访问者的网络地址 public InetSocketAddress getConsumerAddress(); 参数： 无 返回： 访问者的网络地址 获得请求ID public String getRequestID(); 参数： 无 返回： 请求ID 获取请求的Header数据项 public Object getHeader(String key); 参数： key - 数据项的名字 返回： 数据项的值 获取请求的Header public Map getHeader(); 参数： 无 返回： 请求的Header 修改请求Header的数据项 public void setHeader(String key, Object value); 参数： key - 数据项的名字 value - 数据项的值 返回： 无 获得服务名字 public String getServiceName(); 参数： 无 返回： 微服务实际部署的服务名字 注意： 微服务在部署时可以指定服务名字，未必使用@UService中声明的名字，这种机制使得同一个微服务的class可以部署为不同的名字。 获得服务的状态 public int getServiceStatus(); 参数： 无 返回： 服务的运行状态，0:未启动，1:运行中，-1:暂停 获得请求的接口名字 public String getEntryName(); 参数： 无 返回： 请求的接口名字 获得请求接口的注解 public USEntry getEntryAnnotation(); 参数： 无 返回： 请求接口的注解 获得服务容器ID public String getContainerId(); 参数： 无 返回： 服务容器ID，格式：\"host#port\" 获得服务容器的版本 public int getContainerVersion(); 参数： 无 返回： 服务容器的版本，格式：\"1.2.3\" => 1002003，版本分3段，每段占3个整数位（取值：0~999） 获得服务容器的发行状态 public boolean getContainerRelease(); 参数： 无 返回： 服务容器的发行状态：是否Release 检查Container是否开始服务 public boolean isContainerReady(); 参数： 无 返回： 服务容器是否已经进入正常服务状态 获得请求参数的数量 public int getParamCount(); 参数： 无 返回： 请求参数的数量 获得请求参数的值 public Object getParam(int index); 参数： index - 参数的序号，从0开始 返回： 请求参数的值 重新设置请求参数 public void setParam(Object... o); 参数： o - 请求的参数列表 返回： 无 获得请求的标志 public byte getRequestFlag(); 参数： 无 返回： 按位表示的请求标志，0x01：是否丢弃处理结果，0x02：是否通过广播消息返回结果，0x80：是否产生请求的跟踪日志 暂停服务 public void pause(); 参数： 无 返回： 无 重启服务 public void restart(); 参数： 无 返回： 无 获得处理数量 public long[] getStatistics(String service, String entry); 参数： service - 服务名字 entry - 接口名字 返回： 处理数量，格式：[ 处理的请求总量，处理失败的总量 ] 注意： 数量中不包含\"待处理\"或\"处理中\"的请求 获得各个接口的处理数量 public Map getStatistics(String service); 参数： service - 服务名字 返回： 各接口的处理数量，格式：{ \"接口名字\" : [ 处理的请求总量，处理失败的总量 ] } 获得所有服务的处理数量 public Map> getStatistics(); 参数： 无 返回： 所有服务的处理数量，格式：{ \"服务名字\" : { \"接口名字\" : [ 处理的请求总量，处理失败的总量 ] } } 设置成功的处理结果 public void setResultData(Object data); 参数： data - 处理结果 返回： 无 注意： 此接口通常会在容器过滤器@USFilter中使用，详见 @USFilter的说明 设置错误结果 public void setResultError(String msg); 参数： msg - 错误信息 返回： 无 是否有处理结果 public boolean hasResult(); 参数： 无 返回： 是否已经处理完成 或 设置了处理结果 获得结果代码 public int getResultCode(); 参数： 无 返回： 结果代码，ErrorCode.OK（0）表示成功 获得结果数据 public Object getResultData(); 参数： 无 返回： 结果数据，对于void类型的服务接口，返回的结果数据为null 请求是否被转发处理 public boolean isForwarded(); 参数： 无 返回： 是否被转发 创建请求对象 public Context request(String service, Object... entryAndParams) throws Exception; 参数： service - 服务名字 entryAndParams - 接口名字及请求参数 返回： rewin.ubsi.consumer.Context对象 注意： 在微服务中应该使用ServiceContext的request()而不是Context.request()来创建请求对象，这样可以保证： 正确的服务依赖 持续的请求链路跟踪 获得日志对象 public Logger getLogger(); 参数： 无 返回： rewin.ubsi.consumer.Logger对象 "},"appendix/data-type.html":{"url":"appendix/data-type.html","title":"数据类型及编码","keywords":"","body":"基础数据类型及编码方式 UBSI要求微服务接口的请求参数以及返回结果必须采用“标准”的基础数据类型，不能采用“语言相关”的数据结构，这样可以保证在向不同微服务发起请求时，不必依赖服务端定义的数据类型，同时这种机制也为API网关的构造以及以后多语言扩展提供了方便。 UBSI支持的基础数据类型包括： 类型 说明 编码 Java类型 XML方式 JSON方式 null 空 0x00 null null bool 布尔 ...... boolean | Boolean true | false true | false byte 单字节 ...... byte ff {\"$t\":\"byte\", \"$v\":-1} int 整数 ...... char | short | int 12 12 long 长整数 ...... long 123 {\"$t\":\"long\", \"$v\":123} bigint 大整数 ...... BigInteger 12345 {\"$t\":\"bigint\", \"$v\":12345} double 浮点数 ...... float | double 123.45 123.45 或 {\"$t\":\"double\", \"$v\":123} bignum 大浮点数 ...... BigNumber 123.45 {\"$t\":\"bignum\", \"$v\":\"123.45\"} string 字符串 ...... String hello, wor \"hello, world\" map 键值 ...... Map {...} list 列表 ...... List [...] set 集合 ...... Set {\"$t\":\"set\", \"$v\":[...]} bytes 多字节 ...... byte[] a0 b1 {\"$t\":\"bytes\", \"$v\":\"a0b1\"} array 数组 ...... T[] {\"$t\":\"array\", \"$v\":[...]}   在请求/应答过程中，UBSI框架负责将数据按照对应的数据类型编码成字节数据进行传输，同样，对接收到的字节数据也会进行解码，形成\"标准\"类型的数据再传递给微服务或应用进行处理。 XML和JSON表达方式可以在命令行工具或通过API网关发起服务请求时使用。   通常情况下，UBSI对数据的编/解码过程是透明的，不需要开发者进行处理。但下面几种情况需要Java开发者注意： char和short都会转换成int，float会转换为double int[]或String[]等非byte[]型的数组，都会转换为Object[] 非\"标准\"数据类型的Object，会将其非static的public成员变量提取出来，转换成Map "},"appendix/data-codec.html":{"url":"appendix/data-codec.html","title":"数据类型转换API","keywords":"","body":"数据类型转换 rewin.ubsi.common.Codec 将Java数据转换为UBSI基础数据对象 public static Object toObject(Object value); 参数： value - Java数据对象 返回： UBSI基础数据对象 将数据对象转换为指定的数据类型 public static T toType(Object obj, Type type, Type... typeArguments); 参数： obj - Java数据对象 type - 目标数据类型 typeArguments - 如果目标数据类型是\"泛型\"，指明泛型需要的数据类型 返回： 指定数据类型的对象 示例： List value = Codec.toType(new Object[] { 1, 2, 3 }, ArrayList.class, Integer.class); 将数据对象编码为Base64编码的字符串 public static String encode(Object data); 参数： data - Java数据对象 返回： Base64编码的字符串 将Base64编码的字符串解码为数据对象 public static Object decode(String data) throws Exception; 参数： data - Base64编码的字符串 返回： Java数据对象 将数据对象编码为字节数据 public static byte[] encodeBytes(Object data); 参数： data - Java数据对象 返回： 字节数据 将字节数据解码为数据对象 public static Object decodeBytes(byte[] data) throws Exception; 参数： data - 字节数据 返回： Java数据对象 rewin.ubsi.common.XmlCodec 将UBSI格式的xml字符串解码为Java数据对象 public static Object decode(String str) throws Exception; 参数： str - UBSI格式的xml字符串，详见 UBSI数据编码 返回： Java数据对象 将Java数据对象编码为UBSI格式的xml字符串 public static String encode(Object obj, boolean strCData, boolean filterHeader) throws Exception; 参数： obj - Java数据对象 strCData - 是否将String内容放在中 filterHeader - 是否滤掉 返回： UBSI格式的xml字符串 rewin.ubsi.common.JsonCodec 将UBSI格式的json字符串解码为Java数据对象 public static Object fromJson(String str) throws Exception; 参数： str - UBSI格式的json字符串，详见 UBSI数据编码 返回： Java数据对象 将正常格式的json字符串解码为Java数据对象 public static Object simpleJson(String str) throws Exception; 参数： str - 正常格式的json字符串 返回： Java数据对象 将Java数据对象编码为UBSI格式的JsonElement public static JsonElement toJson(Object obj) throws Exception; 参数： obj - Java数据对象 返回： com.google.gson.JsonElement对象 rewin.ubsi.common.Util 将json字符串转换为指定的数据类型 public static T json2Type(String json, Type type, Type... typeArguments); 参数： json - 正常的json格式字符串 type - 目标数据类型 typeArguments - 如果目标数据类型是\"泛型\"，指明泛型需要的数据类型 返回： 指定数据类型的对象 "},"appendix/context.html":{"url":"appendix/context.html","title":"Consumer Context API","keywords":"","body":"rewin.ubsi.consumer.Context 初始化UBSI Consumer运行环境（静态方法） public static void startup(String workPath) throws Exception; 参数： workPath - 指定工作目录（用来查找配置文件） 返回： 无 关闭UBSI Consumer运行环境（静态方法） public static void shutdown(); 参数： 无 返回： 无 设置应用的属性（静态方法） public static void setLogApp(String appAddr, String appTag); 参数： appAddr - 应用的位置 appTag - 应用的分类标签 返回： 无 注意： UBSI Consumer本身的日志输出信息中会使用这些属性 获得应用使用的日志记录器（静态方法） public static Logger getLogger(String appTag, String appID); 参数： appTag - 应用的分类标签 appID - 应用ID 返回： rewin.ubsi.consumer.Logger对象 注意： 如果是在开发微服务，请务必使用ServiceContext的getLogger()来获得Logger对象 得到微服务请求的统计数据（静态方法） public static Register.Statistics getStatistics(String service, String entry); 参数： service - 服务名字 entry - 接口名字 返回： rewin.ubsi.consumer.Register.Statistics对象，结构定义如下： /** 请求统计 */ public static class Statistics { public long request; // 计数器：总请求次数 public long result; // 计数器：总返回次数 public long success; // 计数器：总成功次数 public long max_time; // 计时器：最长的处理时间（毫秒） public String req_id; // 最长处理时间的请求ID } 得到微服务请求的统计数据（静态方法） public static Map getStatistics(String service); 参数： service - 服务名字 返回： 指定服务的各个接口的分立统计，格式：{ \"接口名字\" : } 得到全部微服务请求的统计数据（静态方法） public static Map> getStatistics(); 参数： 无 返回： 所有服务的各个接口的分立统计，格式：{ \"服务名字\" : { \"接口名字\" : } } 创建微服务请求对象（静态方法） public static Context request(String service, Object... entryAndParams) throws Exception; 参数： service - 服务名字 entryAndParams - 接口名字及参数列表 返回： rewin.ubsi.consumer.Context请求对象 注意： 如果是在开发微服务，请务必使用ServiceContext的request()来创建请求对象 获得请求ID public String getReqID(); 参数： 无 返回： 请求ID 获得请求的服务名字 public String getService(); 参数： 无 返回： 服务名字 获得请求的接口名字 public String getEntry(); 参数： 无 返回： 接口名字 获得请求参数的数量 public int getParamCount(); 参数： 无 返回： 请求参数的数量 获得请求参数的值 public Object getParam(int index); 参数： index - 参数的序号，从0开始 返回： 请求参数的值 重新设置请求参数 public void setParam(Object... o); 参数： o - 请求的参数列表 返回： 无 获取请求的Header数据项 public Object getHeader(String key); 参数： key - 数据项的名字 返回： 数据项的值 获取请求的Header public Map getHeader(); 参数： 无 返回： 请求的Header 设置请求Header的数据项 public Context setHeader(String key, Object value); 参数： key - 数据项的名字 value - 数据项的值 返回： 本对象 设置请求Header public Context setHeader(Map header); 参数： header - 请求的Header 返回： 本对象 设置目标微服务的版本 public Context setVersion(int min, int max, int release); 参数： min - 最小版本号，-1表示不改变此项（缺省为0） max - 最大版本号，-1表示不改变此项（缺省为0，表示不限） release - 发行状态，1:必须为Release版；0:必须为非Release版；-1:不限（缺省为-1） 返回： 本对象 设置请求的超时时间 public Context setTimeout(int timeout); 参数： timeout - 超时时间，秒数，0表示不限 返回： 本对象 设置是否使用独立连接发送请求 public Context setConnectAlone(boolean alone); 参数： alone - 是否使用独立连接发送请求（缺省为false） 返回： 本对象 注意： UBSI底层通讯框架采用了多路复用机制，在\"路由\"模式下，多个请求会复用同一个socket连接。当某个请求需要传递大量数据的时候，会占用通讯链路，影响其他请求的处理。这种情况下，可以setConnectAlone(true)，单独创建socket连接来处理这个请求。 获取请求的处理时间 public long getResultTime(); 参数： 无 返回： 请求的处理时间，毫秒数，0表示还未发送请求， 获取结果代码 public int getResultCode(); 参数： 无 返回： 结果代码，ErrorCode.OK（0）表示成功返回 获取结果数据 public Object getResultData(); 参数： 无 返回： 结果数据，对于void类型的服务接口，返回的结果数据为null 设置处理结果 public void setResult(int code, Object data); 参数： code - 结果代码，ErrorCode.OK表示处理成功 data - 结果数据 返回： 无 注意： 此接口通常会在请求过滤器中使用，过滤器的定义如下： /** 请求过滤器 */ public static interface Filter { /** 前置接口，返回：0-正常，-1-拒绝，1-降级（使用Mock数据） */ public int before(Context ctx); /** 后置接口 */ public void after(Context ctx); } 向指定的服务容器直接发送请求（同步方式） public Object direct(String host, int port) throws Exception; 参数： host - 容器的主机地址 port - 容器的监听端口 返回： 处理结果，对于void类型的服务接口，返回的结果数据为null 注意： 直接指定容器发送请求通常用在下面的场景： 对该容器进行配置或监控 测试该容器中部署的微服务实例 每次直接发送请求会单独新建socket连接，不会使用\"多路复用\"机制 向指定的服务容器直接发送请求（异步方式） public void directAsync(String host, int port, ResultNotify notify, boolean message) throws Exception; 参数： host - 容器的主机地址 port - 容器的监听端口 notify - 处理结果的监听器，null表示不需要容器回传结果 message - 是否通过redis广播消息回传结果 返回： 无 注意： 异步方式在请求发送后立即返回，不会阻塞等待，结果数据通过监听器获取，监听器的定义如下： /** 异步方式得到请求结果的回调接口 */ public static interface ResultNotify { /** * 回调入口，code:结果代码(ErrorCode.OK表示成功），result:结果（失败时为错误信息） * 注：如果需要进行高耗时的操作，应启动另外的任务线程进行处理，以免阻塞异步I/O */ public void callback(int code, Object result); } \"路由\"方式发送服务请求（同步方式） public Object call() throws Exception; 参数： 无 返回： 处理结果，对于void类型的服务接口，返回的结果数据为null 注意： \"多路复用\"、\"动态路由\" 机制的请求方式，正常情况下应该使用这种方式请求微服务 \"路由\"方式发送服务请求（异步方式） public void callAsync(ResultNotify notify, boolean message) throws Exception; 参数： notify - 处理结果的监听器，null表示不需要容器回传结果 message - 是否通过redis广播消息回传结果 返回： 无 注意： 当请求需要服务端进行长时间处理时（例如批处理任务），可以考虑采用message为true的请求方式 "},"appendix/error-code.html":{"url":"appendix/error-code.html","title":"错误代码","keywords":"","body":"rewin.ubsi.consumer.ErrorCode 错误代码 public final static int OK = 0; // 处理成功 // 服务端错误代码 public final static int OVERLOAD = 1; // 过载 public final static int SHUTDOWN = 2; // 正在关闭 public final static int NOSERVICE = 3; // 服务未发现 public final static int NOENTRY = 4; // 接口未发现 public final static int STOP = 5; // 服务已停止 public final static int REJECT = 6; // 没有权限 public final static int EXCEPTION = 7; // 处理异常 public final static int FORWARD = 8; // 转发异常 public final static int BREAK = 9; // 接口超时，熔断 public final static int ERROR = 100; // 自定义错误 // 客户端错误代码 public final static int REQUEST = -1; // 请求参数异常 public final static int CONNECT = -2; // 连接异常 public final static int CHANNEL = -3; // Socket通讯异常 public final static int TIMEOUT = -4; // 请求超时 public final static int ROUTER = -5; // 路由失败 public final static int MESSAGE = -6; // 消息机制无效 public final static int MOCK = -7; // 仿真数据无效 public final static int FILTER = -8; // 请求过滤器拦截 public final static int REPEAT = -9; // 请求重复发送 "},"appendix/cli.html":{"url":"appendix/cli.html","title":"命令行工具","keywords":"","body":"命令行工具 UBSI核心包除了服务容器及Consumer组件之外，还提供了几个常用的命令行工具，可以帮助开发者在未部署UBSI治理工具的环境下，也能快速查看和访问微服务。这些工具包括： Request - 发送一个服务请求 Console - 命令行交互 Script - 执行JS脚本 Stress - 性能测试 rewin.ubsi.cli.Request 通过命令行发送一个UBSI服务请求： > java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar rewin.ubsi.cli.Request Usage: Request [-h host] [-p port] [-f req-file] [-router] [-log] [-xml] service entry ... req-file format(json): { \"service\": \"SERVICE_NAME\", \"entry\": \"ENTRY_NAME\", \"timeout\": 0, \"version\": { \"min\": \"0.0.0\", \"max\": \"0.0.0\", \"rel\": -1 }, \"header\": { }, \"params\": [ null -> null bool -> true|false byte -> { \"$t\": \"byte\", \"$v\": -1 } int -> 123 long -> { \"$t\": \"long\", \"$v\": 12345 } bigint -> { \"$t\": \"bigint\", \"$v\": \"1234567\" } double -> 123.45 or { \"$t\": \"double\", \"$v\": 123 } (当值为整数时的表示方式) bignum -> { \"$t\": \"bignum\", \"$v\": \"12345.67\" } bytes -> { \"$t\": \"bytes\", \"$v\": \"b0a1\" } str -> \"hello, world\" array -> { \"$t\": \"array\", \"$v\": [ ... ] } list -> [ ... ] set -> { \"$t\": \"set\", \"$v\": [ ... ] } map -> { ... } id -> { \"$t\": \"id\", \"$v\": \"xxxxxx\" } pattern -> { \"$t\": \"pattern\", \"$v\": \"^H.*T$/2\" } // 0:大小写敏感, 2:大小写不敏感 ] } !! use ' instead of \" if parameters in command line rewin.ubsi.cli.Console 命令行交互工具： > java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar rewin.ubsi.cli.Console UBSI Consumer Console Utility, press ENTER for help localhost#7112> alone [on|off] - show or set connect alone (use for router mode) async [on|off] - show or set receive result through Redis-MQ call - request call to routed Container (switch to router mode) config [router|log] - show local config for Consumer [route|log] direct [host [port]] - request direct to host#port (switch to direct mode) entry service [entry] - show service's entry in Container (direct mode) event channel data ... - put event to channel header [key [value]] - show or set|clear request header's key-value jedis - show Jedis pools json - set JSON data format publish channel data ... - publish message to channel register container|container-raw|restful|clear - show register data of Containers or Restful-Consumer, or clear all register request service entry ... - send request synchronized (use ' instead of \" in json mode parameters) router service - get service's routed path service - show services in Container (direct mode) statistics - show request's statistics report subscribe [channel|pattern#channel|event#channel ...] - subscribe message or event channel time - show request's result time (milli-seconds) timeout [seconds] - show or set request's timeout tracelog [on|off] - show or set access-log's setting unsubscribe [channel|pattern#channel|event#channel ...] - unsubscribe message or event channel use service - use spec service version [min max release] - show or set request service's version xml - set XML data format localhost#7112> rewin.ubsi.cli.Script 通过命令行执行一个JavaScript脚本： > java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar rewin.ubsi.cli.Script Error: JavaScript file \"script.js\" not found! Usage: Script [script.js] [-h host] [-p port] Api of '$' in JavaScript: $._array([...]); 将JS数组转换为Java的Object[] $._bigint('str'); 将JS字符串转换为Java的BigInteger $._bignum('str'); 将JS字符串转换为Java的BigDecimal $._byte(n); 将JS的number转换为Java的byte $._bytes([...]); 将JS的number数组转换为Java的byte[] $._double(n); 将JS的number转换为Java的double $._int(n); 将JS的number转换为Java的int $._list([...]); 将JS数组转换为Java的List（注：Java会将JS的[]当成Map） $._long(n); 将JS的number转换为Java的long $._map({...}); 将JS的对象转换为Java的Map $._set([...]); 将JS数组转换为Java的Set $.async(true|false); 设置同步/异步方式发送请求，默认方式为同步 $.broadcast('channel', data); 发送一条广播消息 $.debug('msg'); 输出一条debug信息 $.error('msg'); 输出一条error信息 $.header({...}); 设置UBSI请求的Header $.host('host', port); 设置UBSI请求的目标容器，host为null表示路由模式 $.info('msg'); 输出一条info信息 $.json(obj); 将obj转换为json字符串，JS解析：val=eval('('+{str}+')'); $.request('service', 'entry', ...); 发送UBSI请求，同步方式返回结果，异步方式直接返回null $.result(data); 设置脚本的返回结果，如果不设置，则将最后一条语句的值作为脚本结果 $.sleep(millis); 暂停millis毫秒 $.throwEvent('channel', data); 发送一条事件消息 $.timeout(seconds); 设置UBSI请求的超时时间（秒数），0表示不限，-1表示使用缺省值 $.version('min_ver', 'max_ver', release); 设置UBSI请求的服务版本限制，release取值：-1-不限，0-非release，1-release Packages.xxx; 引用Java的类，例如：var n = new Packages.java.lang.Integer(10); JavaScript脚本被广泛应用在UBSI的各个关键组件中，包括：测试任务、定时任务、流程编排以及Web服务接口等。 rewin.ubsi.cli.Stress 这是一个简单的性能测试工具，执行方式如下： java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar rewin.ubsi.cli.Stress req.json 1000 参数req.json是构造服务请求的数据文件，内容如下： { \"service\": \"my.samples.demo\", \"entry\": \"getModels\" } \"my.samples.demo\"服务的代码请见：数据注解 参数1000是一个连续发送请求的阈值，具体的工作机制是： 利用UBSI Consumer的非阻塞异步请求机制连续发送指定的请求，并实时计算总请求数量和总应答数量，如果发现二者的差值大于指定的阈值，就暂停发送，等待服务端进行处理，直到差值小于阈值再恢复发送 这种简单的流量控制机制是为了防止服务端出现过载拒绝服务的情况，影响性能数据的准确测量。同时，为了配合性能测试，还需要调整服务容器的负载能力参数 - 在容器的工作目录下手工创建配置文件rewin.ubsi.container.json： { \"host\": \"my-pc\", \"port\": 7112, \"backlog\": 128, \"io_threads\": 4, \"work_threads\": 20, \"overload\": 1000, \"forward\": 0 } 其中： host | port 容器所在服务器的访问地址（建议使用DNS域名，不建议使用IP）和端口 backlog 建立socket连接的等待队列长度 io_threads 用来处理socket I/O的线程数，0表示默认设置 work_threads 处理服务请求的线程数量（注：并不是线程数越多并发处理能力就越强，请根据可用的CPU核数合理配置） overload 等待处理的请求队列长度，如果等待队列已满，新的请求会被拒绝（注：在配合Stress测试时，这个值应该设置为Stress的阈值） forward 如果请求的微服务不在本容器内，是否允许容器转发这个请求（0表示不转发） 注：手工修改配置后需要重启服务容器才能生效 另外，Stress工具使用了\"路由\"方式来访问微服务，与\"直连\"方式不同，\"路由\"方式可以保持socket长连接，并利用多路复用机制提高通讯效率，而\"直连\"方式每次请求都会单独建立一个socket连接，请求完成后关闭，这种方式效率较低，只建议用在特定的\"测试\"或\"监控\"场景。 通常情况下，\"路由\"方式应该配置\"注册中心\"，这样Consumer组件会自动发现可被访问的微服务实例，这种方式需要部署redis server；如果在一个\"简单\"的环境中，不需要\"注册中心\"，也可以通过配置静态路由的方式来指定服务路径 - 手工创建一个配置文件rewin.ubsi.router.json： [ { \"Service\": \"my.samples.demo\", \"Nodes\": [ { \"Host\": \"my-pc\", \"Port\": 7112, \"Weight\": 1 } ] } ] 其中： Weight 参数表示容器节点的权重，如果某个服务有多个节点可选，路由算法会根据权重来动态分配请求 OK！现在所有的准备工作完成，重新执行Stress测试工具，可以得到如下的结果： java -cp ubsi-core-ce-2.3.2-jar-with-dependencies.jar rewin.ubsi.cli.Stress req.json 1000 my.samples.demo:getModels(): { \"my.service.samples.DemoService$RuntimeInfo: 运行信息\": { \"instanceName\": \"java.lang.String, 实例的名字\", \"timestamp\": \"long, 启动时间戳\" } } start stress testing ... --- send: 118165, err: 0, ok: 117642, 15596/s --- send: 85347, err: 0, ok: 84837, 23442/s --- send: 83707, err: 0, ok: 83852, 24088/s --- send: 78001, err: 0, ok: 77832, 23075/s --- send: 70572, err: 0, ok: 70961, 23380/s --- send: 83001, err: 0, ok: 82115, 23773/s q --- send: 59815, err: 0, ok: 59810, 23668/s stress testing stopped! main thread over: 581356 / 581356 / 0 Stress在验证服务请求可以成功返回后，开始连续发送请求并计算每秒的应答数量： 每次按\"return\"，都会显示\"本段时间\"内发送的请求数(send)、失败的请求数(err)、成功返回的请求数(应答数：ok)、每秒收到的应答数 按\"q\"表示退出测试 最后给出\"发送\"/\"成功\"/\"失败\"的请求总数 "},"appendix/js-api.html":{"url":"appendix/js-api.html","title":"JS脚本API","keywords":"","body":"JS脚本API Java代码中的API 如果希望在Java代码中嵌入JS代码的执行能力，可以使用ScriptUtil的API： package rewin.ubsi.common; public class ScriptUtil { /** 脚本输出消息的格式 */ public static class Message { public long time; // 时间戳，毫秒数 public int type; // 消息类别，LogUtil.DEBUG | INFO | ERROR public String text; // 消息内容 } /** API说明，格式：{ \"方法\": \"说明\" } */ public static Map Api; /** 脚本的执行结果 */ public Object Result; /** 脚本执行过程中的输出消息记录 */ public List Messages; /** 构造函数 */ public ScriptUtil() {} /** 构造函数，指定服务容器的地址 */ public ScriptUtil(String host, int port); /** 构造函数，指定日志记录的属性 */ public ScriptUtil(String appTag, String appID, String tips); /** 设置脚本日志的输出级别：\"NONE\" | \"DEBUG\" | \"INFO\" | \"ERROR\" */ public static void setLogLevel(String level); /** 获得脚本日志的输出级别 */ public static String getLogLevel(); /** 获得JavaScript脚本执行引擎 * 参数： * context - ScriptUtil对象实例，为JS脚本提供'$'对象 * var - 供JS脚本使用的其他环境变量 * 返回： * javax.script.ScriptEngine对象 */ public static ScriptEngine getEngine(ScriptUtil context, Map var); /** 执行JavaScript脚本 * 参数： * engine - JavaScript执行引擎 * js - JavaScript脚本代码 * 返回： * JavaScript脚本代码的执行结果 */ public static Object runJs(ScriptEngine engine, String js) throws Exception; /** 执行JavaScript脚本 * 参数： * js - JavaScript脚本代码 * context - ScriptUtil对象实例，为JS脚本提供'$'对象 * var - 供JS脚本使用的其他环境变量 * 返回： * JavaScript脚本代码的执行结果 */ public static Object runJs(String js, ScriptUtil context, Map var) throws Exception; } JS代码中的API 通过ScriptUtil加载的JS代码，都可以使用\"$\"对象提供的API： $.host('container-host', port) 设置UBSI请求的目标容器，container-host为null表示路由模式，缺省为路由模式 $.header({...}) 设置UBSI请求的Header $.version('min_ver', 'max_ver', release) 设置UBSI请求的服务版本限制，release取值：-1-不限，0-非release，1-release $.timeout(seconds) 设置UBSI请求的超时时间（秒数），0表示不限，-1表示使用缺省值 $.async(true|false) 设置同步/异步方式发送请求，缺省为同步方式 $.request('service', 'entry', ...) 发送UBSI请求，同步方式返回结果，异步方式直接返回null $.result(data) 设置脚本的返回结果，如果不设置，则将最后一条语句的值作为脚本结果 $.sleep(millis) 暂停millis毫秒 $.json(obj) 将obj转换为json字符串，JS解析：val=eval('(' + json + ')'); $.debug('msg') 输出一条debug信息 $.info('msg') 输出一条info信息 $.error('msg') 输出一条error信息 $.broadcast('channel', data) 发送一条广播消息 $.throwEvent('channel', data) 发送一条事件消息 $._byte(n) 将JS的number转换为Java的byte $._int(n) 将JS的number转换为Java的int $._long(n) 将JS的number转换为Java的long $._bigint('str') 将JS字符串转换为Java的BigInteger $._double(n) 将JS的number转换为Java的double $._bignum('str') 将JS字符串转换为Java的BigDecimal $._bytes([...]) 将JS的number数组转换为Java的byte[] $._map({...}) 将JS的对象转换为Java的Map $._list([...]) 将JS数组转换为Java的List（注：Java会将JS的[]当成Map） $._set([...]) 将JS数组转换为Java的Set $._array([...]) 将JS数组转换为Java的Object[] 另外在JS代码中还可以直接使用Packages.xxx来引用UBSI核心包关联的任意Java类，例如： var array = new Packages.java.util.ArrayList(); "},"appendix/redis.html":{"url":"appendix/redis.html","title":"Redis消息事件API","keywords":"","body":"redis访问 - rewin.ubsi.common.JedisUtil 检测redis是否可用 public static boolean isInited(); 参数： 无 返回： 当前是否已经正常连接到了redis server 获取一个Jedis实例 public static Jedis getJedis(); 参数： 无 返回： redis.clients.jedis.Jedis对象，后续可以使用这个对象访问redis；如果失败会抛出异常 注意： Jedis对象使用结束后，需要主动调用close()以释放资源，或者使用 try-with-resource 机制 如果操作中会切换redis的Database，需要在完成操作后切换回 JedisUtil.DATABASE 示例： try (Jedis jedis = JedisUtil.getJedis()) { //do your work jedis.select(JedisUtil.DATABASE); // 如果之前执行过select操作 } 发送一个广播消息 public static void publish(String channel, Object data); 参数： channel - 广播频道 data - 消息数据 返回： 无 注意： 所有\"订阅\"了该频道的\"监听器\"都会收到这个广播 发送一个事件 public static void putEvent(String channel, Object data); 参数： channel - 事件频道 data - 事件数据 返回： 无 注意： 在分布式环境下，即便存在多个订阅了该频道的监听器，但只有一个能收到这个事件（抢占式处理） 频道监听器 - JedisUtil.Listener public static abstract class Listener { /** 广播监听的回调入口 */ public abstract void onMessage(String channel, Object message) throws Exception; /** 事件监听的回调入口 */ public abstract void onEvent(String channel, Object event) throws Exception; /** 监听广播频道 */ public void subscribe(String... channels); /** 监听广播频道（\"*\"表示通配符） */ public void subscribePattern(String... patterns); /** 监听事件频道（在一个Java进程中，同一个事件频道只能存在一个监听器） */ public void subscribeEvent(String... channels) throws Exception; /** 取消广播监听 */ public void unsubscribe(String... channels); /** 取消广播监听 */ public void unsubscribePattern(String... patterns); /** 取消事件监听 */ public void unsubscribeEvent(String... channels); } 注意： 如果使用JedisUtil.publish()发布广播或者JedisUtil.putEvent()发送\"事件\"，必须使用JedisUtil.Listener来监听 发送的广播或者事件数据可以是任意数据类型，但是在监听器接收时，会转换为UBSI基础数据类型 在回调接口onMessage或onEvent中，如果需要进行高耗时的操作，应启动另外的任务线程进行处理，以免阻塞异步I/O 示例： if ( JedisUtil.isInited() ) { // 创建频道监听器 JedisUtil.Listener listener = new JedisUtil.Listener() { @Override public void onMessage(String channel, Object message) { System.out.print(\"\\n~~~ receive message from [\" + channel + \"]: \"); Request.printJson(message); } @Override public void onEvent(String channel, Object event) { System.out.print(\"\\n~~~ receive event from [\" + channel + \"]: \"); Request.printJson(event); } } listener.subscribe(\"msg1\", \"msg2\"); // 监听广播频道 listener.subscribeEvent(\"evt1\", \"evt2\"); // 监听事件频道 } "},"appendix/crypto.html":{"url":"appendix/crypto.html","title":"国密算法API","keywords":"","body":"国密算法 - rewin.ubsi.common.Crypto SM3数据散列 public static byte[] sm3Digest(byte[] data); 参数： data - 源数据 返回： 散列值，长度32字节 HMAC数据签名 public static byte[] sm3HMAC(byte[] data, byte[] key); 参数： data - 源数据 key - 密钥，长度不限 返回： 签名，长度32字节 计算SM4加密数据的长度 public static int sm4EncryptSize(int size); 参数： size - 源数据的长度 返回： 加密数据的长度 SM4数据加密 public static byte[] sm4EncryptEcb(byte[] data, byte[] key); 参数： data - 源数据，以128位（16字节）为一组，会自动补位 key - 密钥，长度必须16字节 返回： 加密数据 SM4数据解密 public static byte[] sm4DecryptEcb(byte[] data, byte[] key); 参数： data - 加密数据，长度必须为16字节的整倍数 key - 密钥，长度必须16字节 返回： 解密数据 "}}